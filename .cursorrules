Dart 일반 가이드라인

기본 원칙
	•	모든 코드와 문서화는 영어로 작성한다.
	•	각 변수와 함수(매개변수 및 반환값)의 타입을 항상 선언한다.
	•	any 사용을 지양한다.
	•	필요한 타입을 정의한다.
	•	함수 내에 빈 줄을 남기지 않는다.
	•	파일당 하나의 export만 허용한다.

명명 규칙
	•	클래스에는 PascalCase를 사용한다.
	•	변수, 함수, 메서드에는 camelCase를 사용한다.
	•	파일 및 디렉터리 이름에는 underscores_case를 사용한다.
	•	환경 변수에는 UPPERCASE를 사용한다.
	•	매직 넘버를 피하고 상수를 정의한다.
	•	함수는 동사로 시작해야 한다.
	•	불리언 변수에는 동사를 사용한다. 예: isLoading, hasError, canDelete 등.
	•	약어 대신 완전한 단어를 사용하며 철자를 정확히 표기한다.
	•	단, API, URL과 같은 표준 약어는 예외.
	•	i, j는 반복문에서, err는 오류에서, ctx는 컨텍스트에서, req, res, next는 미들웨어 함수 매개변수에서 사용 가능.

함수
	•	여기서 함수로 이해되는 것은 메서드에도 적용된다.
	•	하나의 목적을 가진 짧은 함수를 작성한다(20줄 미만).
	•	함수 이름은 동사와 다른 단어를 조합하여 작성한다.
	•	반환값이 불리언이면 isX, hasX, canX 등의 형식을 사용한다.
	•	반환값이 없다면 executeX, saveX 등의 형식을 사용한다.
	•	중첩 블록을 피한다.
	•	초기에 검증 및 반환 처리.
	•	유틸리티 함수로 추출.
	•	중첩된 함수를 피하기 위해 고차 함수(map, filter, reduce 등)를 사용한다.
	•	간단한 함수(3줄 미만)에는 화살표 함수를 사용한다.
	•	비간단한 함수에는 이름이 있는 함수를 사용한다.
	•	null 또는 undefined를 검사하는 대신 기본 매개변수 값을 사용한다.
	•	RO-RO를 사용하여 함수 매개변수를 줄인다.
	•	여러 매개변수를 전달할 때는 객체를 사용한다.
	•	결과를 반환할 때도 객체를 사용한다.
	•	입력 인수 및 출력 값을 위한 필요한 타입을 선언한다.
	•	하나의 추상화 레벨을 유지한다.

데이터
	•	기본 타입의 남용을 지양하고, 복합 타입으로 데이터를 캡슐화한다.
	•	함수 내에서 데이터 유효성 검사를 피하고, 내부 유효성 검사를 갖춘 클래스를 사용한다.
	•	데이터는 불변성을 선호한다.
	•	변경되지 않는 데이터는 readonly를 사용한다.
	•	변경되지 않는 리터럴은 as const를 사용한다.

클래스
	•	SOLID 원칙을 준수한다.
	•	상속보다 구성을 선호한다.
	•	계약을 정의하기 위해 인터페이스를 선언한다.
	•	하나의 목적을 가진 작은 클래스를 작성한다.
	•	200줄 미만.
	•	공개 메서드 10개 미만.
	•	속성 10개 미만.

예외
	•	예상치 못한 오류를 처리하기 위해 예외를 사용한다.
	•	예외를 처리할 경우:
	•	예상된 문제를 해결하거나.
	•	컨텍스트를 추가해야 한다.
	•	그렇지 않으면 전역 핸들러를 사용한다.

테스트
	•	테스트는 Arrange-Act-Assert 방식을 따른다.
	•	테스트 변수는 명확하게 이름을 지정한다.
	•	예: inputX, mockX, actualX, expectedX 등.
	•	각 공개 함수에 대해 단위 테스트를 작성한다.
	•	테스트 더블로 종속성을 시뮬레이션한다.
	•	단, 실행 비용이 크지 않은 서드파티 종속성은 예외.
	•	각 모듈에 대해 수용 테스트를 작성한다.
	•	Given-When-Then 방식을 따른다.

Flutter 전용

기본 원칙
	•	클린 아키텍처를 사용한다.
	•	모듈이 필요한 경우 모듈로 코드를 구성한다.
	•	컨트롤러가 필요한 경우 컨트롤러로 코드를 구성한다.
	•	서비스가 필요한 경우 서비스로 코드를 구성한다.
	•	리포지토리가 필요한 경우 리포지토리로 코드를 구성한다.
	•	엔티티가 필요한 경우 엔티티로 코드를 구성한다.
	•	데이터 지속성을 위해 리포지토리 패턴을 사용한다.
	•	비즈니스 로직은 Riverpod으로 관리하며 컨트롤러 패턴을 사용한다.
	•	상태를 유지하려면 keepAlive를 사용한다.
	•	UI 상태 관리를 위해 Freezed를 사용한다.
	•	컨트롤러는 항상 메서드를 입력으로 받아 UI 상태를 업데이트하며 UI에 영향을 준다.
	•	종속성 관리를 위해 getIt을 사용한다.
	•	서비스와 리포지토리를 위한 싱글톤을 사용한다.
	•	유스 케이스를 위한 팩토리를 사용한다.
	•	컨트롤러를 위한 지연 싱글톤을 사용한다.
	•	라우트를 관리하기 위해 AutoRoute를 사용한다.
	•	페이지 간 데이터를 전달하려면 extras를 사용한다.
	•	재사용 가능한 코드를 관리하려면 확장을 사용한다.
	•	테마 관리를 위해 ThemeData를 사용한다.
	•	번역 관리를 위해 AppLocalizations를 사용한다.
	•	상수 값을 관리하기 위해 constants를 사용한다.
	•	위젯 트리가 너무 깊어지면 렌더링 속도와 메모리 사용량에 영향을 미친다. 따라서 플랫 구조가 효율성을 높인다.
	•	플랫한 위젯 구조는 코드를 이해하고 수정하기 쉽게 만든다. 재사용 가능한 컴포넌트는 코드 조직을 더 잘 관리할 수 있게 한다.
	•	Flutter에서 위젯 중첩을 깊게 하는 것을 피한다. 중첩된 위젯은 가독성, 유지보수성, 성능에 부정적인 영향을 미칠 수 있다. 복잡한 위젯 트리를 더 작고 재사용 가능한 컴포넌트로 나누도록 한다.
	•	상태 관리를 용이하게 하려면 트리를 얕게 유지한다.
	•	대형 위젯을 더 작고 집중된 위젯으로 분리한다.
	•	재구성을 줄이기 위해 const 생성자를 가능한 한 많이 활용한다.

테스트
	•	Flutter 표준 위젯 테스트를 사용한다.
	•	각 API 모듈에 대해 통합 테스트를 작성한다.